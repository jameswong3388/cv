name: RenderCV (Update PDFs on Merge)

on:
  # Update the tracked PDFs only after a PR is merged into the base branch.
  # Use pull_request_target so the workflow has permission to push commits to the base branch.
  pull_request_target:
    types: [closed]
    branches: [main, master]

permissions:
  contents: write
  issues: write
  pull-requests: write

concurrency:
  # Serialize updates per base branch to avoid two merged PRs racing and producing
  # non-fast-forward push failures or dueling PDF update PRs.
  group: rendercv-merge-${{ github.repository }}-${{ github.event.pull_request.base.ref }}
  cancel-in-progress: true

jobs:
  update:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout base branch (post-merge)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}
          fetch-depth: 0
          persist-credentials: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install RenderCV
        run: |
          python -m pip install --upgrade pip
          python -m pip install "rendercv[full]"

      - name: Render CV + cover letter
        run: |
          rendercv render cv/cv.yaml -nomd -nohtml -nopng
          rendercv render cl/cl.yaml -nomd -nohtml -nopng

      - name: Stage rendered PDFs
        run: |
          # Stage any PDFs RenderCV produces in these folders (handles renames/filename changes).
          git add -A "cv" "cl"
          git diff --cached --name-status > rendercv_diff.txt || true
          git diff --cached --stat > rendercv_stat.txt || true

      - name: Commit rendered PDFs (if changed)
        id: commit
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          if git diff --cached --quiet; then
            echo "No PDF changes to commit."
            echo "changed=false" >> "$GITHUB_OUTPUT"
            echo "commit_sha=" >> "$GITHUB_OUTPUT"
            echo "push_ok=false" >> "$GITHUB_OUTPUT"
            echo "pushed_ref=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git commit -m "chore(rendercv): update rendered PDFs [skip ci]"
          
          BASE_REF="${{ github.event.pull_request.base.ref }}"
          FALLBACK_BRANCH="rendercv/pdf-update-pr-${{ github.event.pull_request.number }}"
          
          echo "Attempting to push directly to ${BASE_REF}..."
          if git push origin "HEAD:${BASE_REF}"; then
            echo "push_ok=true" >> "$GITHUB_OUTPUT"
            echo "pushed_ref=${BASE_REF}" >> "$GITHUB_OUTPUT"
          else
            echo "Direct push to ${BASE_REF} failed (likely branch protection)."
            echo "Pushing to fallback branch ${FALLBACK_BRANCH} and opening a PR..."
            git push --force origin "HEAD:${FALLBACK_BRANCH}"
            echo "push_ok=false" >> "$GITHUB_OUTPUT"
            echo "pushed_ref=${FALLBACK_BRANCH}" >> "$GITHUB_OUTPUT"
          fi
          
          echo "changed=true" >> "$GITHUB_OUTPUT"
          echo "commit_sha=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"

      - name: Upload PDFs (artifacts)
        if: steps.commit.outputs.changed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: rendered-pdfs-merged-pr-${{ github.event.pull_request.number }}
          path: |
            cv/JamesWong_CV.pdf
            cl/Cover letter.pdf

      - name: Comment on PR with merge update result
        if: always()
        uses: actions/github-script@v7
        env:
          RENDERCV_CHANGED: ${{ steps.commit.outputs.changed }}
          RENDERCV_COMMIT_SHA: ${{ steps.commit.outputs.commit_sha }}
          RENDERCV_PUSH_OK: ${{ steps.commit.outputs.push_ok }}
          RENDERCV_PUSHED_REF: ${{ steps.commit.outputs.pushed_ref }}
        with:
          script: |
            const fs = require("fs");
            
            const prNumber = context.payload.pull_request.number;
            const baseRef = context.payload.pull_request.base.ref;
            const headRepo = context.repo;
            
            const changed = process.env.RENDERCV_CHANGED === "true";
            const commitSha = process.env.RENDERCV_COMMIT_SHA || "";
            const pushOk = process.env.RENDERCV_PUSH_OK === "true";
            const pushedRef = process.env.RENDERCV_PUSHED_REF || "";
            const commitUrl = commitSha
              ? `https://github.com/${context.repo.owner}/${context.repo.repo}/commit/${commitSha}`
              : "";
            
            function readText(path) {
              try {
                return fs.readFileSync(path, "utf8").trim();
              } catch {
                return "";
              }
            }
            
            const nameStatus = readText("rendercv_diff.txt");
            const stat = readText("rendercv_stat.txt");
            
            const lines = [];
            lines.push("### RenderCV: PDFs updated on merge");
            lines.push(`- **Base branch**: \`${baseRef}\``);
            
            if (changed) {
              if (pushOk) {
                lines.push(`- **Result**: ✅ PDFs updated and pushed to \`${baseRef}\`: ${commitSha ? `[${commitSha.slice(0, 7)}](${commitUrl})` : "updated"}`);
              } else if (pushedRef) {
                // Fallback: open/update a PR from pushedRef -> baseRef
                const title = "chore(rendercv): update rendered PDFs";
                const { data: pulls } = await github.rest.pulls.list({
                  owner: headRepo.owner,
                  repo: headRepo.repo,
                  state: "open",
                  base: baseRef,
                  per_page: 100,
                });
                let existing = pulls.find((p) => p.head && p.head.ref === pushedRef);
                
                let pdfPrNumber = existing?.number;
                let prUrl = existing?.html_url;
                if (!existing) {
                  const { data: created } = await github.rest.pulls.create({
                    owner: headRepo.owner,
                    repo: headRepo.repo,
                    title,
                    // Be explicit about repo owner to avoid ambiguity.
                    head: `${headRepo.owner}:${pushedRef}`,
                    base: baseRef,
                    body: "Auto-generated by RenderCV merge workflow because direct push to the protected base branch was not allowed.",
                  });
                  pdfPrNumber = created.number;
                  prUrl = created.html_url;
                  existing = created;
                }
                
                lines.push(`- **Result**: ⚠️ Direct push to \`${baseRef}\` was not allowed; opened PR instead: ${prUrl ? prUrl : `\`${pushedRef}\``}`);
                if (commitSha) lines.push(`- **Commit**: [${commitSha.slice(0, 7)}](${commitUrl})`);

                // Prefer enabling GitHub auto-merge (waits for required checks) if available.
                // If auto-merge isn't enabled for the repo, fall back to a best-effort "wait then merge" attempt.
                if (pdfPrNumber) {
                  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
                  let pr = null;

                  // Fetch PR details (including node_id) and allow time for mergeability computation.
                  for (let i = 0; i < 10; i++) {
                    const { data } = await github.rest.pulls.get({
                      owner: headRepo.owner,
                      repo: headRepo.repo,
                      pull_number: pdfPrNumber,
                    });
                    pr = data;
                    if (pr.mergeable !== null && pr.mergeable_state !== "unknown") break;
                    await sleep(2000);
                  }

                  // 1) Try enabling auto-merge (best option when required checks exist).
                  const prNodeId = pr?.node_id || existing?.node_id;
                  let autoMergeEnabled = false;
                  let autoMergeMethod = "";
                  if (prNodeId) {
                    const methods = ["SQUASH", "MERGE", "REBASE"];
                    let lastErr = null;
                    for (const method of methods) {
                      try {
                        await github.graphql(
                          `
                          mutation($pullRequestId: ID!, $mergeMethod: PullRequestMergeMethod!) {
                            enablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId, mergeMethod: $mergeMethod }) {
                              pullRequest { number }
                            }
                          }
                          `,
                          { pullRequestId: prNodeId, mergeMethod: method }
                        );
                        autoMergeEnabled = true;
                        autoMergeMethod = method.toLowerCase();
                        break;
                      } catch (e) {
                        lastErr = e;
                      }
                    }

                    if (!autoMergeEnabled && lastErr) {
                      // Auto-merge might be disabled at the repo level; we'll fall back to a manual merge attempt below.
                      lines.push(`- **Auto-merge**: ℹ️ Could not enable GitHub auto-merge: ${lastErr?.message || String(lastErr)}`);
                    }
                  } else {
                    lines.push("- **Auto-merge**: ℹ️ Could not enable GitHub auto-merge (missing PR node id).");
                  }

                  if (autoMergeEnabled) {
                    lines.push(`- **Auto-merge**: ✅ Enabled auto-merge for PDF update PR #${pdfPrNumber}${autoMergeMethod ? ` (method=${autoMergeMethod})` : ""}.`);
                  } else if (!pr || pr.mergeable !== true) {
                    lines.push(
                      `- **Auto-merge**: ❌ Not mergeable (mergeable=${pr?.mergeable}, state=${pr?.mergeable_state}). This is usually due to required checks/reviews or merge conflicts.`
                    );
                  } else {
                    // 2) Best-effort: wait a bit for required checks to finish, then merge.
                    // (If the branch requires reviews, this will remain blocked and we won't be able to merge.)
                    const maxWaitMs = 10 * 60 * 1000; // 10 minutes
                    const pollMs = 10 * 1000;
                    const start = Date.now();
                    while (Date.now() - start < maxWaitMs) {
                      const { data } = await github.rest.pulls.get({
                        owner: headRepo.owner,
                        repo: headRepo.repo,
                        pull_number: pdfPrNumber,
                      });
                      pr = data;
                      if (pr.mergeable_state === "clean") break;
                      await sleep(pollMs);
                    }

                    if (pr.mergeable_state !== "clean") {
                      lines.push(
                        `- **Auto-merge**: ❌ Still blocked after waiting (state=${pr.mergeable_state}). This is usually due to required checks or required reviews.`
                      );
                    } else {
                      const methods = ["squash", "merge", "rebase"];
                      let merged = false;
                      let usedMethod = "";
                      let lastErr = null;
                      for (const method of methods) {
                        try {
                          await github.rest.pulls.merge({
                            owner: headRepo.owner,
                            repo: headRepo.repo,
                            pull_number: pdfPrNumber,
                            merge_method: method,
                          });
                          merged = true;
                          usedMethod = method;
                          break;
                        } catch (e) {
                          lastErr = e;
                        }
                      }

                      if (merged) {
                        lines.push(`- **Auto-merge**: ✅ Merged PDF update PR #${pdfPrNumber}${usedMethod ? ` (method=${usedMethod})` : ""}.`);
                      } else {
                        lines.push(`- **Auto-merge**: ❌ Merge attempt failed: ${lastErr?.message || String(lastErr)}`);
                      }
                    }
                  }
                }
              } else {
                lines.push(`- **Result**: ⚠️ PDFs committed but could not be pushed (no fallback branch info).`);
                if (commitSha) lines.push(`- **Commit**: [${commitSha.slice(0, 7)}](${commitUrl})`);
              }
            } else {
              lines.push("- **Result**: ℹ️ No PDF changes; nothing to commit.");
            }
            
            if (nameStatus) {
              lines.push("");
              lines.push("**Changed files:**");
              lines.push("```");
              lines.push(nameStatus);
              lines.push("```");
            }
            
            if (stat) {
              lines.push("");
              lines.push("**Diff stat:**");
              lines.push("```");
              lines.push(stat);
              lines.push("```");
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: lines.join("\n"),
            });


